<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>RPGchess</title>
    <style>
      #game-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      </style>
  </head>
  <body>
    <div id="game-container"></div>
    <script src="/socket.io/socket.io.js"></script>
    <script src="../scripts/phaser.min.js"></script>
    <script src="../scripts/GameBundle.js"></script>
    <script>

    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      width: window.innerWidth,
      height: window.innerHeight,
      scene: {
        preload: preload,
        create: create,
        update: update
      }
    };
    const gameScene = new Phaser.Game(config);    // BUG: canvas size is set according to visible screen size, not the entire screen size 

    let playerPerspective = '<%= playerPerspective %>';   // "WHITE" or "BLACK"
    let gameId = '<%= gameId %>';

    let startingPosition = "8 8/rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR";
    let game = new GameBundle.Game(1, 2, startingPosition);   // game logic
    let gameState = game.gameState;
    let board = gameState.board;

    let boardSquareSprites = [];   // 2D array of sprites representing the board squares
    let pieceSprites = [];    // 2D array of sprites representing the pieces

    function preload() {
      this.load.image('backgroundGradient', '../images/backgroundGradient.avif');
      this.load.image('blackSquare', '../images/blackSquare.png');
      this.load.image('whiteSquare', '../images/whiteSquare.png');
      this.load.image('whitePawn', '../images/whitePawn.png');
      this.load.image('whiteRook', '../images/whiteRook.png');
      this.load.image('whiteKnight', '../images/whiteKnight.png');
      this.load.image('whiteBishop', '../images/whiteBishop.png');
      this.load.image('whiteQueen', '../images/whiteQueen.png');
      this.load.image('whiteKing', '../images/whiteKing.png');
      this.load.image('blackPawn', '../images/blackPawn.png');
      this.load.image('blackRook', '../images/blackRook.png');
      this.load.image('blackKnight', '../images/blackKnight.png');
      this.load.image('blackBishop', '../images/blackBishop.png');
      this.load.image('blackQueen', '../images/blackQueen.png');
      this.load.image('blackKing', '../images/blackKing.png');

    }

    function create() {
      const background = this.add.image(0, 0, 'backgroundGradient');
      background.setOrigin(0);
      background.setScale(this.sys.game.canvas.width / background.width, this.sys.game.canvas.height / background.height);

      let squareImageSize = this.textures.get('blackSquare').getSourceImage();
      let squareSize = 0.8 * window.innerHeight / board.ROWS;     // vertical size of board always coveres 80% of the screen height
      let squareScale = squareSize / squareImageSize.width;
      let boardPosition = {x: (window.innerWidth - squareSize * board.COLUMNS) / 2, y: (window.innerHeight - squareSize * board.ROWS) / 2}; // top left corner of the board
      

      for(let row = 0; row < board.ROWS; row++) {
        let currentRow = [];
        for(let col = 0; col < board.COLUMNS; col++) {
          let color = (row + col) % 2 === 0 ? 'white' : 'black'; 
          let squareSprite = this.add.sprite(boardPosition.x + col * squareSize,boardPosition.y + row * squareSize, color + 'Square');
          squareSprite.setOrigin(0, 0); 
          squareSprite.setScale(squareScale);
          squareSprite.row = row;
          squareSprite.col = col;
          squareSprite.x = boardPosition.x + col * squareSize;
          squareSprite.y = boardPosition.y + row * squareSize;
          currentRow.push(squareSprite);
        }
        boardSquareSprites.push(currentRow);
      }


      for(let row of board.boardSetup) {
        let currentRow = [];
        for(let piece of row)
        {
          if(piece.type != ".")
          {
            let pieceName = ".";
            if(piece.type === "p") pieceName = "Pawn";
            else if(piece.type === "r") pieceName = "Rook";
            else if(piece.type === "n") pieceName = "Knight";
            else if(piece.type === "b") pieceName = "Bishop";
            else if(piece.type === "q") pieceName = "Queen";
            else if(piece.type === "k") pieceName = "King";

            let pieceSprice = null;
            let pieceColor = piece.side === "WHITE" ? "white" : "black";
            if(playerPerspective === "WHITE")
              pieceSprite = this.add.sprite(boardSquareSprites[piece.initialSquare[0]][piece.initialSquare[1]].x, boardSquareSprites[piece.initialSquare[0]][piece.initialSquare[1]].y, pieceColor + pieceName);
            else
              pieceSprite = this.add.sprite(boardSquareSprites[board.ROWS - piece.initialSquare[0] - 1][board.COLUMNS - piece.initialSquare[1] - 1].x, boardSquareSprites[board.ROWS - piece.initialSquare[0] - 1][board.COLUMNS - piece.initialSquare[1] - 1].y, pieceColor + pieceName);
         
            pieceSprite.setOrigin(0, 0);
            pieceSprite.setScale(squareScale);
            pieceSprite.row = piece.initialSquare[0];
            pieceSprite.col = piece.initialSquare[1];
            pieceSprite.side = piece.side;
            pieceSprite.setInteractive();
            pieceSprite.setDepth(1);

            currentRow.push(pieceSprite);
          }
          else
            currentRow.push(undefined);
        }
        pieceSprites.push(currentRow);
      }

      this.input.on("pointerdown", (pointer, gameObjects) => {
        this.selectedPiece = gameObjects[0];
        if(this.selectedPiece != undefined && this.selectedPiece.side === playerPerspective)
        {
          this.selectedPiece.setDepth(2);
          this.startingSquare = {row: this.selectedPiece.row, col: this.selectedPiece.col};
        }

      }, this);

      this.input.on("pointermove", (pointer) => {
        if(this.selectedPiece != undefined && this.selectedPiece.side === playerPerspective)
        {
          this.selectedPiece.x = pointer.x - squareSize / 2;
          this.selectedPiece.y = pointer.y - squareSize / 2;
        }
      }, this);

      this.input.on("pointerup", (pointer) => {
        if(this.selectedPiece != undefined && this.selectedPiece.side === playerPerspective)
        {
          let currentTurn = game.getGameState().getTurn();  // returns 0 for white, 1 for black
          let currentTurnColor = currentTurn === 0 ? "WHITE" : "BLACK";
          if(!(currentTurnColor === playerPerspective)) // if it's not the player's turn
          {
            console.log("Not your turn!");
            console.log(pieceSprites);
            cancelMove(this);
            return;
          }
          if(pointer.x < boardPosition.x || pointer.x > boardPosition.x + squareSize * board.COLUMNS || pointer.y < boardPosition.y || pointer.y > boardPosition.y + squareSize * board.ROWS) // if the pointer is not on the board
          { // if the mouse is outside the board
            cancelMove(this);
            return;
          }
          
          let targetSquareSprite = null;
          if(playerPerspective === "WHITE")
            targetSquareSprite = boardSquareSprites[Math.floor((pointer.y - boardPosition.y) / squareSize)][Math.floor((pointer.x - boardPosition.x) / squareSize)];
          else  // get actual square from memory representation, mirrored to the picked square
            targetSquareSprite = boardSquareSprites[board.ROWS - Math.floor((pointer.y - boardPosition.y) / squareSize) - 1][board.COLUMNS - Math.floor((pointer.x - boardPosition.x) / squareSize) - 1];

          let isValidMove = game.getGameState().movePiece([this.selectedPiece.row, this.selectedPiece.col], [targetSquareSprite.row, targetSquareSprite.col]); 
          if(!isValidMove)  // illegal move by game rules
          {
            cancelMove(this);
            return;
          }

          // move is valid, update the board
          if(playerPerspective === "WHITE")
          { 
            this.selectedPiece.x = boardSquareSprites[targetSquareSprite.row][targetSquareSprite.col].x;
            this.selectedPiece.y = boardSquareSprites[targetSquareSprite.row][targetSquareSprite.col].y;
          }
          else
          {
            this.selectedPiece.x = boardSquareSprites[board.ROWS - targetSquareSprite.row - 1][board.COLUMNS - targetSquareSprite.col - 1].x;
            this.selectedPiece.y = boardSquareSprites[board.ROWS - targetSquareSprite.row - 1][board.COLUMNS - targetSquareSprite.col - 1].y;
          }
          this.selectedPiece.row = targetSquareSprite.row;
          this.selectedPiece.col = targetSquareSprite.col;
          let capturedPiece = pieceSprites[targetSquareSprite.row][targetSquareSprite.col];
          if(capturedPiece != undefined)
            capturedPiece.destroy();

          this.selectedPiece.setDepth(1);
          pieceSprites[targetSquareSprite.row][targetSquareSprite.col] = this.selectedPiece;
          pieceSprites[this.startingSquare.row][this.startingSquare.col] = undefined;

          socket.emit("move", {from: [this.startingSquare.row, this.startingSquare.col], to: [targetSquareSprite.row, targetSquareSprite.col]});
          this.selectedPiece = undefined;
          this.startingSquare = undefined;

        }
      }, this);


      let playerColor = playerPerspective === "WHITE" ? 0 : 1;
      var socket = io({query: {gameId: gameId, playerColor: playerColor}});

      socket.on("move", (move) => {
        let movedPiece = pieceSprites[move.from[0]][move.from[1]];
        let capturedPiece = pieceSprites[move.to[0]][move.to[1]];
        pieceSprites[move.to[0]][move.to[1]] = movedPiece;
        pieceSprites[move.from[0]][move.from[1]] = undefined;

        if(capturedPiece != undefined)
          capturedPiece.destroy();

        if(playerPerspective === "WHITE")
        {
          movedPiece.x = boardSquareSprites[move.to[0]][move.to[1]].x;
          movedPiece.y = boardSquareSprites[move.to[0]][move.to[1]].y;
        }
        else
        {
          movedPiece.x = boardSquareSprites[board.ROWS - move.to[0] - 1][board.COLUMNS - move.to[1] - 1].x;
          movedPiece.y = boardSquareSprites[board.ROWS - move.to[0] - 1][board.COLUMNS - move.to[1] - 1].y;
        }
      });
    }

    function update() {

    }

    function cancelMove(scene) // scene = Phaser scene; move the selected piece back to square it was on before the player started dragging it
    {
      if(scene.selectedPiece != undefined && playerPerspective === "WHITE" && scene.selectedPiece.side === "WHITE")
      {
        scene.selectedPiece.x = boardSquareSprites[scene.startingSquare.row][scene.startingSquare.col].x;
        scene.selectedPiece.y = boardSquareSprites[scene.startingSquare.row][scene.startingSquare.col].y;
      }
      else
      {
        scene.selectedPiece.x = boardSquareSprites[board.ROWS - scene.startingSquare.row - 1][board.COLUMNS - scene.startingSquare.col - 1].x;
        scene.selectedPiece.y = boardSquareSprites[board.ROWS - scene.startingSquare.row - 1][board.COLUMNS - scene.startingSquare.col - 1].y;
      }
      scene.selectedPiece.row = scene.startingSquare.row;
      scene.selectedPiece.col = scene.startingSquare.col;
      scene.selectedPiece.setDepth(1);
      scene.selectedPiece = undefined;
      scene.startingSquare = undefined;
    }


    </script>
  </body>
</html>